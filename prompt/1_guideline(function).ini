Render.com에 배포된 JSON 전용 웹 API아래 기능을 구현하는 것을 목표로 합니다.
사용자는 서비스 엔드포인트에 주어진 파라미터값을 입력하면, 서비스는 지정된 테이블에 기록된 API를 사용하여 티커와 이벤트 타입, 이벤트 날짜 등을 기록하고 
정보는 supabase DB에 저장합니다.

- 확정된 기술 스택
    - DB:Supabase Postgres
        - Project URL: https://fgypclaqxonwxlmqdphx.supabase.co
        - API Key: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZneXBjbGFxeG9ud3hsbXFkcGh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjYwMjE1ODksImV4cCI6MjA4MTU5NzU4OX0.w3NUKwBfd29xzxhEzosZOyk5OMX4TAgqdgGfaG1y6Zg
    - Web API (Render.com)

- 공통 구현 원칙 (LLM 지침 적용 시 필수)
    - 우선순위(Conflict Resolution)
        - DB 스키마/제약조건/트리거(tables.ini)가 최종 권위이며, guideline의 로직 규칙은 DB 규칙을 위반할 수 없다.
        - 동일 항목에 대해 지침(문서)과 DB 제약이 충돌하는 것으로 보이면, DB에 맞추고 로그에 'POLICY_CONFLICT_DB_SCHEMA' 경고를 남긴다.
    - 책임 경계(Separation of Concerns)
        - LLM(또는 애플리케이션 로직)은 '계산/판단/정책 적용/검증'을 수행한다.
        - DB 트리거/제약이 자동으로 보정/검증하는 필드는 애플리케이션이 재계산/재작성하지 않는다(중복 로직 금지).
    - 시간/날짜 필드 정의(다층 기준 금지)
        - event_date(저장): 레코드 식별 및 정렬에 쓰는 이벤트 시점(예: consensus=publishedDate, earning=date).
        - calc_base_date(계산): 가치/성과 계산 기준일. 원칙적으로 event_date와 같지만, 필요 시 별도 변수로 분리해 로그에 명시한다.
        - priceTrend_base_date(시계열): dayOffset=0의 기준일. 원칙적으로 event_date와 같으며, 정책(countStart/countEnd)은 이 기준에서 적용한다.
        - 시간/날짜 처리 및 정규화 원칙
            - 입력 정규화 (Input Normalization):
                - API로부터 수신된 모든 날짜 문자열은 로직 처리 전 **Python의 datetime 객체(UTC 기준)**로 변환한다.
                - 시간 정보가 없는 날짜(YYYY-MM-DD)는 **YYYY-MM-DD 00:00:00+00:00 (UTC 자정)**으로 간주하여 변환한다.
                - ISO 8601 포맷(T, Z 포함)은 파싱 후 UTC로 통일한다.
            - 저장 포맷 (Storage Format):
                - DB 저장 시 모든 타임스탬프 필드는 Postgres의 timestamptz (UTC) 타입을 따른다.
                - jsonb 내부 날짜는 타입 강제가 불가하므로 문자열로 저장하되, UTC ISO8601(+00:00) 포맷을 강제한다.
            - 책임 경계 준수를 위한 날짜 필드 명세표
                필드명 (Column/Key),위치 (Location),책임 주체 (Source),설명 및 처리 규칙
                event_date,DB Column,API / App,"[Business Key]이벤트가 발생한 실제 시점.API 응답의 date, publishedDate 등을 파싱하여 애플리케이션이 주입. 시간 정보가 없는 날짜(YYYY-MM-DD)는 정규화 규칙 준수하여 DB에 변환하여 기록"
                created_at,DB Column,DB Trigger,[Audit] 레코드가 최초 생성된 시스템 시간.DEFAULT now()로 자동 처리되므로 INSERT 문에서 제외.
                updated_at,DB Column,DB Trigger,[Audit] 레코드가 수정된 시스템 시간.트리거에 의해 자동 갱신되므로 UPDATE 문에서 제외.
                lastUpdated,JSONB (Payload),API,API 제공처에서 관리하는 메타 데이터이며 정규화 규칙 준수.
                generated_at_utc,JSONB (Meta),App,데이터 처리/가공이 일어난 시점.애플리케이션이 로직 수행 시점의 시간을 생성하여 주입.
    - 적재 전략 명시(Upsert vs Insert-only)
        - Insert-only(기존 레코드 변경 금지): evt_earning (중복 시 DO NOTHING)
        - Upsert(갱신 허용): config_lv3_market_holidays, config_lv3_targets, evt_consensus, config_lv3_analyst, [table.events]
    - 불일치 발견시 자동으로 보정하지 않고 사용자와 확인 후 결정해야 한다.
---
- definition
    - API
        - [sourcedDataAPI.getHolidays]: config_lv1_api_list.fmp-holidays-by-exchange
            - schema
                {
                    "date": "date",
                    "name": "name",
                    "exchange": "exchange",
                    "isClosed": "isClosed",
                    "adjOpenTime": "adjOpenTime",
                    "adjCloseTime": "adjCloseTime",
                    "isFullyClosed": "isFullyClosed"
                }
        - [sourcedDataAPI.getTargets]: config_lv1_api_list.fmp-company-screener
            - schema
                {
                    "beta": "beta",
                    "isEtf": "isEtf",
                    "price": "price",
                    "isFund": "isFund",
                    "sector": "sector",
                    "ticker": "symbol",
                    "volume": "volume",
                    "country": "country",
                    "exchange": "exchange",
                    "industry": "industry",
                    "marketCap": "marketCap",
                    "companyName": "companyName",
                    "exchangeShortName": "exchangeShortName",
                    "isActivelyTrading": "isActivelyTrading",
                    "lastAnnualDividend": "lastAnnualDividend"
                }
        - [sourcedDataAPI.getConsensus]: config_lv1_api_list.fmp-price-target
            - schema
                // =========================
                // (중요) sourcedDataAPI 표준 스키마(정규화 결과) 정의
                // =========================
                // - 본 schema는 "원천 API의 raw 키 목록"이 아니라, 애플리케이션이 downstream 단계에서 일관되게 사용하기 위한 "내부 표준 스키마"를 정의한다.
                // - 원천 API(raw)에는 publishedDate가 존재하나, 어댑터/수집 단계에서 반드시 event_date로 rename하여 반환한다.
                // - downstream(getConsensus 적재/계산)은 publishedDate 키를 직접 참조하지 않고, event_date만을 참조한다. (혼동 방지)
                {
                "ticker": "symbol",
                "newsURL": "newsURL",
                "newsTitle": "newsTitle",
                "analystName": "analystName",
                "newsBaseURL": "newsBaseURL",
                "priceTarget": "priceTarget",
                "newsPublisher": "newsPublisher",
                "event_date": "publishedDate",
                // event_date 규칙(강제):
                // - publishedDate를 timestamptz로 파싱 가능한 형태로 제공해야 한다.
                "adjPriceTarget": "adjPriceTarget",
                "analystCompany": "analystCompany",
                "priceWhenPosted": "priceWhenPosted"
                }
        - [sourcedDataAPI.getEarning]: config_lv1_api_list.fmp-earnings-calendar
            - schema
                // =========================
                // (권장) sourcedDataAPI 표준 스키마(정규화 결과) 정의
                // =========================
                // - 원천 API(raw)에는 date가 존재하나, 어댑터/수집 단계에서 반드시 event_date로 rename하여 반환한다.
                // - downstream(getEarning 적재/계산)은 date 키를 직접 참조하지 않고, event_date만을 참조한다. (혼동 방지)
                {
                "event_date": "date",
                "ticker": "symbol",
                "epsActual": "epsActual",
                "lastUpdated": "lastUpdated",
                "epsEstimated": "epsEstimated",
                "revenueActual": "revenueActual",
                "revenueEstimated": "revenueEstimated"
                }
    - table
        - [table.getHolidays]: config_lv3_market_holidays
            - [sourcedDataAPI.getHolidays] to [table.getHolidays] schema
                {
                "target_table": [table.getHolidays],
                "rules": {
                    "row_object_token": "$row",
                    "upsert_conflict_keys": ["exchange", "date"],   // 거래소+날짜 기준 upsert
                    "update_strategy": "upsert"
                },
                "mapping": {
                    "exchange": "exchange",                         // API: exchange → 컬럼: exchange
                    "date": "date",                                 // API: date → 컬럼: date (DATE 형으로 파싱)
                    "name": "name",                                 // API: name → 컬럼: name
                    "is_closed": "isClosed",                        // API: isClosed → 컬럼: is_closed
                    "adj_open_time": "adjOpenTime",                 // API: adjOpenTime → 컬럼: adj_open_time
                    "adj_close_time": "adjCloseTime",               // API: adjCloseTime → 컬럼: adj_close_time
                    "is_fully_closed": "isFullyClosed",             // API: isFullyClosed → 컬럼: is_fully_closed
                    "updated_at": "$now"                            // 호출 시점 기준으로 갱신 시간 기록
                },
                "constants": {
                }
                }
        - [table.getTargets]: config_lv3_targets
            - [sourcedDataAPI.getTargets] to [table.getTargets] schema
                {
                    "target_table": [table.getTargets],
                    "rules": {
                        "row_object_token": "$row",
                        "upsert_conflict_keys": ["ticker"],         // ticker 기준 upsert
                        "update_strategy": "upsert"                 // 필요 시 엔진 규칙에 맞게 이름 조정
                    },
                    "mapping": {
                        // NOTE: sourcedDataAPI.getTargets 스키마에서 이미 ticker 키로 표준화됨 따라서 table mapping은 표준 키(ticker)를 참조한다.
                        "ticker": "ticker",                         // API: symbol → 컬럼: ticker
                        "sector": "sector",                         // API: sector → 컬럼: sector
                        "industry": "industry",                     // API: industry → 컬럼: industry
                        "response_key": "$row",                     // 전체 응답 1건을 그대로 jsonb로 저장
                        "updated_at": "$now"                        // 입력/갱신 시점 기록
                    },
                    "constants": {
                    }
                }
        - [table.getConsensus]: evt_consensus
            - [sourcedDataAPI.getConsensus] to [table.getConsensus] schema
                {
                "target_table": "[table.getConsensus]",             // public.evt_consensus
                "rules": {
                    "row_object_token": "$row",
                    "upsert_conflict_keys": ["ticker", "event_date", "analyst_name", "analyst_company"],
                    "update_strategy": "upsert",

                    // prev 계산을 위한 윈도우 정의 (논리적 정의 / 의사코드)
                    // ⚠ 본 정의는 "계산 규칙 설명" 용도이며, DB 또는 엔진이 자동으로 prev 값을 생성함을 의미하지 않는다. 실제 계산은 getConsensus 2단계(애플리케이션 로직)에서 수행된다.
                    //
                    // 계산 규칙:
                    // - 파티션: (ticker, analyst_name, analyst_company)
                    // - 정렬: event_date DESC
                    // - "직전(prev)"이란, DESC 정렬 기준 바로 다음(더 과거) 레코드
                    "window": {
                        "partition_by": ["ticker", "analyst_name", "analyst_company"],
                        "order_by": [{"event_date": "desc"}],
                        "prev_value_method": "lead"
                    }
                },

                "mapping": {
                    // =========================
                    // 1단계: 원천 적재 (Raw Upsert)
                    // =========================
                    // - 본 mapping은 "원천 데이터 보존"만을 담당한다.
                    // - 파생 컬럼은 1단계에서 생성/갱신하지 않는다. (price_target_prev, price_when_posted_prev, direction, response_key.prev)
                    // - 파생 컬럼은 getConsensus 2단계에서 UPDATE-by-key로 반영한다.

                    // NOTE: sourcedDataAPI.getConsensus 스키마에서 이미 ticker 키로 표준화됨
                    "ticker": "ticker",
                    "event_date": "event_date",
                    // event_date 저장 규칙(강제)
                    // - publishedDate를 timestamptz로 파싱하여 UTC로 정규화 후 저장한다.
                    // - 파싱 실패/시간대 모호(예: timezone 누락) 시 400으로 실패 처리한다.
                    "analyst_name": "analystName",
                    "analyst_company": "analystCompany",
                    "price_target": "priceTarget",
                    "price_when_posted": "priceWhenPosted",

                    // response_key.last만 1단계에서 기록한다.
                    // - response_key.prev는 2단계에서 계산 후 UPDATE한다.
                    "response_key": {
                        "last": "$row"
                    }

                    // (금지) 1단계에서 아래 컬럼을 채우기 위한 의사코드 표기를 추가하지 않는다.
                    // - $lead(...), $case(...) 등
                    // - 이유: 실제 계산이 엔진/DB 자동 실행으로 오해될 수 있음
                },

                "constants": {}
                }
        - [table.getEarning]: evt_earning
            - [sourcedDataAPI.getEarning] to [table.getEarning] schema
                {
                "target_table": [table.getEarning],
                "rules": {
                    "row_object_token": "$row",
                    "conflict_keys": ["ticker", "event_date"],
                    "update_strategy": "insert_only"
                },
                "mapping": {
                    // NOTE: sourcedDataAPI.getEarning 스키마에서 이미 ticker 키로 표준화됨
                    // NOTE: sourcedDataAPI.getEarning 스키마에서 이미 event_date로 표준화됨
                    "ticker": "ticker",            // API: symbol → 컬럼: ticker
                    "event_date": "event_date",            // API: date → 컬럼: event_date
                    "response_key": "$row"
                },
                "constants": {
                }
                }
        - [table.events]: txn_events
        - [table.analyst]: config_lv3_analyst
            - (POST /fillAnalyst 결과) to [table.analyst] schema
                {
                "target_table": [table.analyst],   // public.config_lv3_analyst
                "rules": {
                    "row_object_token": "$row",

                    // (analyst_name, analyst_company)는 각각 NULL 허용
                    // - 단, 둘 다 NULL이면 적재 대상에서 제외(스킵)
                    // - NULL을 포함한 조합도 "1건"으로 식별되도록 generated key 컬럼을 사용
                    "upsert_conflict_keys": ["analyst_name_key", "analyst_company_key"],
                    "update_strategy": "upsert",

                    // 둘 다 NULL인 경우는 스킵(원칙)
                    "skip_when": [
                    "analyst_name is null and analyst_company is null"
                    ]
                },
                "mapping": {
                    // 원본 키 (NULL 허용)
                    "analyst_name": "analyst_name",
                    "analyst_company": "analyst_company",

                    // generated key 컬럼(analyst_name_key/analyst_company_key)은
                    // DB의 GENERATED ALWAYS STORED 컬럼이므로 애플리케이션에서 INSERT/UPDATE로 값을 쓰지 않는다.
                    // 단, upsert_conflict_keys에서는 동일 컬럼을 계속 사용한다(충돌 판정은 DB가 생성한 key 기준).

                    // 집계 결과를 jsonb로 저장
                    "response_key": {
                    "performance": "performance",
                    "summary": "summary",
                    "policy": "policy_snapshot",
                    "meta": "calc_meta"
                    },

                    // 호출 시점 기준 갱신 시간 기록
                    "updated_at": "$now"
                },
                "constants": {}
                }
        - [table.metric]: config_lv2_metric
---
- 엔드포인트, 파라미터 트리
    - GET /sourceData
        - query
            - mode (optional)
                - type: string
                - format:
                    - 단일 값: "holiday" | "target" | "consensus" | "earning"
                    - 복수 값: "<기능1>,<기능2>,..." (comma-separated)
                - rules:
                    - 미지정 시: 기본 순서로 전체 실행 (holiday → target → consensus → earning)
                    - 복수 지정 시: 중복 제거 후 기본 순서로 실행
                    - 허용되지 않은 값 포함 시: 400 Bad Request (권장 정책)
                - affects:
                    - mode에 "earning" 포함 시에만 하위 파라미터 past 적용
            - past (optional; effective only if mode includes "earning")
                - type: boolean
                - default: false
                - rules:
                    - false: 미래 구간만 조회
                    - true: 미래 + 과거(최대 5년) 조회
            - calc_mode (optional; consensus 내부 2단계 계산 모드)
                - type: string
                - allowed: "maintenance"
                - default: (unset) → "default"
                - rules:
                    - 허용되지 않은 값: 400 Bad Request
                - affects:
                    - getConsensus 2단계(변경 감지/기록) 실행 범위 결정
            - calc_scope (required if calc_mode="maintenance")
                - type: string
                - allowed:
                    - "all"
                    - "ticker"
                    - "event_date_range"
                    - "partition_keys"
                - rules:
                    - 누락 시: 400 Bad Request
                    - scope별 추가 파라미터 요구사항은 아래 참조
            - tickers (required if calc_mode="maintenance" and calc_scope="ticker")
                - type: string[]
                - example: ["AAPL","MSFT"]
            - from (required if calc_mode="maintenance" and calc_scope="event_date_range")
                - type: string (YYYY-MM-DD)
            - to (required if calc_mode="maintenance" and calc_scope="event_date_range")
                - type: string (YYYY-MM-DD)
            - partitions (required if calc_mode="maintenance" and calc_scope="partition_keys")
                - type: array<object>
                - item shape:
                    - ticker: string (required)
                    - analyst_name: string | null (optional/nullable)
                    - analyst_company: string | null (optional/nullable)

    - POST /setEventsTable
        - headers
            - Content-Type: application/json
        - body
            - none (빈 JSON 허용)
        - query
            - overwrite (optional; sector/industry 보강 정책)
                - type: boolean
                - default: false
                - rules:
                    - false: sector/industry가 NULL인 row만 업데이트
                    - true: sector/industry가 NULL이거나, ticker 매칭 시 [table.getTargets] 값과 불일치하는 row까지 모두 업데이트
            - dryRun (optional)
                - type: boolean
                - default: false
                - rules:
                    - true: DB insert 미수행, 탐지/예정 건수만 반환
            - schema (optional)
                - type: string
                - default: "public"
                - rules:
                    - 존재하지 않는 스키마 지정 시: 400 Bad Request (권장)
            - table (optional)
                - type: string
                - format: "<table1>,<table2>,..." (comma-separated)
                - rules:
                    - 미지정 시: schema 내 `evt_%` 테이블 전체 자동 탐색
                    - 지정 시: 지정된 테이블만 탐색 대상으로 제한
                    - (권장) 지정된 테이블은 `evt_` prefix를 만족해야 함
                        - 미만족 시: 400 Bad Request (권장)

    - POST /backfillEventsTable
        - headers
            - Content-Type: application/json
        - body
            - none (빈 JSON 허용)
        - query
            - overwrite (optional)
                - type: boolean
                - default: false
                - rules:
                    - false: value_* 내부 null 값만 부분 갱신
                    - true: value_* 전체 갱신 (전제조건 충족 레코드만)

    - POST /fillAnalyst
        - headers
            - Content-Type: application/json
        - body
            - none (빈 JSON 허용)
        - query
            - (external input params 없음)
                - note:
                    - 실행 전/중 내부 Guard 규칙은 정책/DB 상태로 검증 (예: POLICY_NOT_FOUND 등)
---
- 엔드포인트 구현시 준수 사항
    - 각 엔드포인트에서 사용할 상태값 및 로그 양식
        - 공통 상태값(Key) 정의(모든 엔드포인트 동일 키, UI 파싱 안정화)
            - reqId: 요청 단위 UUID
            - endpoint: 예) GET /sourceData
            - phase: 예) getConsensus.fetch
            - elapsedMs: 누적 경과(ms)
            - progress: done/total/pct
            - etaMs: 남은 시간 추정(ms)
            - rate: perMin/limitPerMin/usagePct
            - batch: size/mode (dynamic batch)
            - counters: success/fail/skip/update/insert/conflict
            - policy: dryRun/overwrite/past/insertOnly 등
            - warn: 경고 코드 배열 (예: POLICY_CONFLICT_DB_SCHEMA)
            - msg: 1줄 요약(사람용)
        - 1줄 로그 포맷(고정, key=value)
            [${endpoint} | ${phase}] elapsed=${elapsedMs}ms | progress=${done}/${total}(${pct}%) | eta=${etaMs}ms | rate=${perMin}/${limitPerMin}(${usagePct}%) | batch=${size}(${mode}) | ok=${success} fail=${fail} skip=${skip} upd=${update} ins=${insert} cf=${conflict} | warn=${warnCodes} | ${msg}
        - 상세한 로그 규칙
            - 모든 처리 단계는 endpoint.functionName 형식으로 명명
            - 각 단계는 식별에 필요한 핵심 정보만 1줄 로그로 출력
            - 로그만으로 오류 지점 및 병목 구간을 추적할 수 있어야 함
        - 결과 반환 규칙
            - 각 레코드 단위 성공/실패 상태 반환
            - summary로 총 성공/실패/스킵 집계 정보 포함
    - 경제적 호출: 모든 엔드포인트는 경제적으로 API를 호출할 것
        - 최소 요청 호출: 
            - config_lv1_api_list 테이블에서 호출되는 모든 API는 호출 전에 호출을 최소화할 수 있는지 반드시 검토할 것
            - 동일 API에서 ticker가 unique하지 않고, api 컬럼에 {ticker} 및 날짜 범위 변수가 포함된 경우:
                - ticker 단위로 1회만 호출
                - 해당 ticker가 요구하는 전체 event_date 범위를 병합하여 호출
                - 호출 기간은 config_lv0_policy 기준으로 시작일/종료일 산출
                    - 예시
                        - [table.metric].priceEodOHLC로 API를 호출하여 각 거래일의 OHLC 조회
                            - 조회시 ticker가 같고, 기간이 여러개라면 하나의 티커에 대해 모든 기간을 커버하는 범위의 날짜로 api를 호출하여 단 1번의 호출로 하나의 ticker의 모든 기간 OHLC를 기록할 것
                                - unique한 ticker가 가지고있는 모든 event_date를 기준으로 엔드포인트에 따라 config_lv0_policy에서 정하는 정책을 확인하여 탐색 시작일과, 종료일을 계산하여 API를 호출할 것
                                - 예시
                                    ticker/source/event_date
                                    aaa/evt_earnings/2021-10-11
                                    aaa/evt_earnings/2025-12-08
                                    rgti/evt_consensus/2025-10-11
                                    rgti/evt_earnings/2022-12-10  

                                    대상이 위와 같이 4개인 경우 unique한 ticker는 2개, 
                                    [table.metric].priceEodOHLC로 호출할 api는 아래의 2개
                                    https://financialmodelingprep.com/stable/historical-price-eod/full?symbol=rgti&from=2022-11-10&to=2025-11-11&apikey=8AP6lUDNsrBwtx5IzVoDliKnG186rBSt
                                    https://financialmodelingprep.com/stable/historical-price-eod/full?symbol=aaa&from=2021-09-11&to=2026-01-08&apikey=8AP6lUDNsrBwtx5IzVoDliKnG186rBSt
        - 최단 시간 호출: 
            - config_lv1_api_list 테이블에서 호출되는 모든 API는 분당 최대 호출량을 사용할 것
            - Rate Limit 기준:
                - config_lv1_api_list.api_service → config_lv1_api_service.usagePerMin
            - Rate Limit을 초과하지 않으면서 최대 처리량 유지
            - batchSize는 고정값 금지
                - 직전 rate / limitPerMin 비율 기준으로 동적 조정
            - 현재 진행 중 기능의 예상 남은 시간(eta)을 로그에 출력
                - etaMs = (elapsedMs / progress.pct) - elapsedMs
---
- 주요 기능
    - 흐름: 결론 도출에 필요한 기반 정보 수집
        - GET /sourceData
            - 요청 파라미터
                - mode (optional)
                    - mode 미지정: 아래 기능을 정의된 순서대로(getHolidays → getTargets → getConsensus → getEarning) 전체 실행
                    - mode 단일 값 지정: 지정한 단일 기능만 실행
                        - mode=holiday: getHolidays 실행
                        - mode=target: getTargets 실행
                        - mode=consensus: getConsensus 실행
                        - mode=earning: getEarning 실행
                            - 하위 변수(mode에 earning이 포함된 경우에만 작동하는 변수)
                                - past 
                                    - past=false (기본값):  getEarning 기능의 미래 조회만 실행 
                                    - past=true: getEarning 기능의 미래 조회, 과거 조회를 모두 실행 
                    - mode 복수 값 지정(콤마 구분): 지정한 기능들만 선택 실행
                        - 형식: mode=<기능1>,<기능2>,...
                            - 예시: mode=holiday,target → getHolidays와 getTargets만 실행
                    - 동작 규칙:
                        - 입력된 값은 콤마로 분리하여 각각 기능으로 매핑한다.
                        - 중복 값은 1회로 처리한다.
                        - 실행 순서는 기본 실행 순서(getHolidays → getTargets → getConsensus → getEarning)를 따른다.
                        - 알 수 없는 값이 포함되면 해당 값은 무시하거나(또는 오류 반환) 정책을 명시한다. (권장: 400 Bad Request로 명확히 실패 처리)
            - 기능
                - getHolidays: 
                    - [sourcedDataAPI.getHolidays]로 정보 수집
                    - [table.getHolidays] 테이블에 schema 형식으로 값을 입력
                        - (exchange, date) 기준으로 upsert 처리한다.
                        - 이미 존재하는 레코드는 갱신하고, 신규 레코드는 추가한다.
                - getTargets: 
                    - [sourcedDataAPI.getTargets]로 정보 수집
                    - [table.getTargets] 테이블에 schema 형식으로 값을 입력 (upsert)    
                - getConsensus:
                    - 목적: [sourcedDataAPI.getConsensus]로 컨센서스 데이터를 수집하고, 대상 ticker만 필터링하여 [table.getConsensus]에 적재하며, 동일 (ticker, analyst_name, analyst_company) 조합 내에서 price_target 변화 정보까지 함께 기록한다.
                    - 실행 모드 정의
                        - (주의) 여기서 말하는 calc_mode/calc_scope는 GET /sourceData의 mode(holiday/target/consensus/earning)와 별개 파라미터다.
                        - 기본 모드(Default, 기본값)
                            - 성능/안정성 목적
                            - 이번 run의 1단계 Raw Upsert 입력에 포함된
                              (ticker, analyst_name, analyst_company) 파티션만
                              2단계 변경 감지 및 UPDATE 대상이 된다.
                        - 유지보수 모드(Maintenance)
                            - 명시적으로 calc_mode=maintenance 가 지정된 경우에만 활성화
                            - 데이터 복구(backfill), 정책 변경, 버그 수정 후 재계산 목적
                            - 명시된 범위(scope)에 한해 파티션 재계산을 허용한다.
                            - scope별 필수 입력 파라미터는 아래와 같이 고정한다.
                                - scope=all
                                    - 추가 파라미터 금지
                                    - 전체 파티션 재계산을 의미하며, 명시적 요청으로만 허용
                                - scope=ticker
                                    - 필수: tickers: string[]   // 예: ["AAPL","MSFT"]
                                - scope=event_date_range
                                    - 필수:
                                        - from: YYYY-MM-DD
                                        - to:   YYYY-MM-DD
                                    - 범위 해석: from ≤ event_date ≤ to (inclusive)
                                - scope=partition_keys
                                    - 필수:
                                        - partitions:
                                            - ticker
                                            - analyst_name (nullable)
                                            - analyst_company (nullable)
                            - 각 항목은 (ticker, analyst_name, analyst_company) 완전 키로 처리한다.
                        - calc_mode 파라미터 처리 규칙(강제)
                            - calc_mode 미지정: 기본 모드로 실행한다.
                            - calc_mode 지정 시 허용 값:
                                - "maintenance"
                            - 허용되지 않은 calc_mode 값이 지정된 경우:
                                - 400 Bad Request로 실패 처리한다.
                    - 수집 및 필터링
                        - [table.getTargets]에서 유효한 ticker 목록을 조회한다.
                            - {ticker} 단위로 병렬 실행 가능
                        - 각 {ticker}에 대해 [sourcedDataAPI.getConsensus]를 호출하여 데이터를 수집한다.
                    - 1단계: 원천 적재 (Raw Upsert)
                        - 필터링된 데이터만 [table.getConsensus]에 정의된 schema로 upsert 한다.
                        - upsert 키는 반드시 DB unique constraint와 동일하게 ["ticker", "event_date", "analyst_name", "analyst_company"] 를 사용한다.
                        - 본 단계에서는 아래 파생 컬럼을 계산하거나 갱신하지 않는다.
                            - price_target_prev
                            - price_when_posted_prev
                            - direction
                            - response_key.prev
                        - 본 단계의 목적은 **원천 데이터의 안정적 적재**이며, 변화 정보 계산은 반드시 2단계에서 수행한다.

                    - 2단계: 변경 감지 및 기록 (동기 실행)
                        - 본 단계는 **1단계 원천 적재가 모두 완료된 이후에만 실행**한다.
                        - 2단계 처리 시 동시성 규칙은 다음을 따른다.
                            - 동일 (ticker, analyst_name, analyst_company) 파티션은 **동시에 처리하지 않으며** 동일 파티션에 대해서는 항상 **단일 실행 흐름만 허용**한다.
                            - 서로 다른 (ticker, analyst_name, analyst_company) 파티션은 시스템 리소스 및 정책이 허용하는 범위 내에서 **병렬 처리할 수 있다**.
                            - 위 규칙을 만족하기 위해 파티션 단위의 동기화(락/큐잉 등)를 적용한다.
                        - 대상 파티션 결정 규칙
                            - 기본 모드(Default)
                                - "영향받은 파티션"만 처리한다.
                                - 영향받은 파티션 정의:
                                    - 이번 run의 1단계 Raw Upsert **입력 payload**에 포함된 (ticker, analyst_name, analyst_company) DISTINCT 조합
                                    - DB 결과(insert/update 여부)는 판단 기준에 포함하지 않는다.
                                    - 즉, 입력 기준으로 파티션을 확정하며, 실행 중 동적 변경은 허용하지 않는다.
                                - 위 파티션 외의 데이터는 이번 run에서 **절대 UPDATE하지 않는다.**

                            - 유지보수 모드(Maintenance)
                                - 반드시 처리 범위(calc_scope)를 명시해야 한다.
                                - 허용 calc_scope 유형(택1 이상):
                                    - calc_scope=all               // 전체 파티션 재계산 (명시적)
                                    - calc_scope=ticker            // 특정 ticker 목록
                                    - calc_scope=event_date_range  // 특정 event_date 범위
                                    - calc_scope=partition_keys    // (ticker, analyst_name, analyst_company) 조합
                                - calc_scope가 명시되지 않은 경우:
                                    - 400 Bad Request로 실패 처리한다.
                        - 전제
                            - `event_date`는 동일 조합 내에서 비교 기준 시점으로 사용한다.
                            - 비교는 항상 정렬 기준상 인접한 직전(더 과거) 레코드와 수행한다.
                        - 계산 규칙
                            - 파티션 기준: (ticker, analyst_name, analyst_company)
                            - 정렬 기준: event_date DESC
                            - 각 행에 대해 직전(더 과거) 레코드의 값을 다음 컬럼에 기록한다.
                                - price_target_prev
                                - price_when_posted_prev
                            - price_target이 직전 값 대비 증가한 경우 direction = "up"
                            - price_target이 직전 값 대비 감소한 경우 direction = "down"
                            - 동일하거나 직전 값이 없는 경우 direction = null
                            - response_key에는 다음 정보를 기록한다.
                                - last: 현재 행의 원본 데이터
                                - prev: 직전(더 과거) 레코드의 원본 데이터
                        - 동작 규칙
                            1. 대상 ticker에 대한 데이터 수집 및 필터링을 수행한다.
                            2. 필터링된 데이터를 [table.getConsensus]에 원천 적재(upsert)한다. (1단계)
                            3. 실행 모드에 따라 대상 파티션을 확정한다.
                                - 기본 모드: 영향받은 파티션만
                                - 유지보수 모드: calc_scope로 명시된 파티션
                            4. 각 대상 파티션에 대해 DB에서 파티션 전체 행을 event_date DESC 기준으로 조회하여 변화 정보를 계산한다.
                            5. 계산된 prev 값, direction, response_key를 **row key 기준(update-by-key)**으로 [table.getConsensus]에 반영한다.
                                - UPDATE 조건: (ticker, event_date, analyst_name, analyst_company)
                                - 원천 컬럼(price_target 등)은 수정하지 않는다.
                                - response_key.last는 재작성하지 않는다.
                - getEarning: 
                    - [sourcedDataAPI.getEarning]로 정보 수집
                        - 수집된 정보 필터링
                            - (ticker, event_date) 기준으로 INSERT 한다.
                            - 중복 충돌 시 ON CONFLICT (ticker, event_date) DO NOTHING 으로 처리한다. (기존 레코드 갱신 금지)
                            - (강제) 기존 레코드 갱신 금지: update/upsert를 절대 사용하지 않는다. insert 성공/중복 무시만 허용한다.
                            - 즉, 신규 레코드만 추가되며 기존 레코드는 변경하지 않는다.
                        - 변수 설정
                            - {fromDate}, {toDate}는 [sourcedDataAPI.getEarning] 호출 시 필수 파라미터
                            - 조회 가능한 과거 범위는 오늘로부터 최대 5년 전까지로 제한
                            - {fromDate}~{toDate} 구간이 길면 응답이 잘릴 수 있으므로, 조회는 배치(Chunk) 단위로 분할하여 실행
                            - 변수의 날짜 포맷은 `YYYY-MM-DD`로 할 것
                        - 조회 정책
                            - 과거 조회(별도 요청 시에만 실행)
                                - 목적: 오늘 기준 **최대 5년 전까지의 과거 데이터를 백필(backfill)** 한다.
                                - 실행 조건: `mode` 또는 별도 파라미터로 “과거 조회”가 명시된 경우에만 실행한다.
                                - 배치 분할 규칙:
                                    - 조회 시작일: `today - 5 years`
                                    - 조회 종료일: `today`
                                    - 조회 구간을 **7일 단위**로 분할하여 순차 실행한다.
                                    - 각 배치 호출은 다음 형태를 따른다.
                                        - 배치 i: `{fromDate}=D`, `{toDate}=min(D+6일, today)`
                            - 미래 조회(기능 실행 시 기본 동작)
                                - 목적: 가까운 미래 구간의 earnings calendar를 주기적으로 갱신한다.
                                - 실행 조건: `getEarning` 실행 시 기본으로 수행한다.
                                - 배치 분할 규칙(4개 윈도우, 각 7일):
                                    - Window 1: `{fromDate}=today`, `{toDate}=today+7일`
                                    - Window 2: `{fromDate}=today+8일`, `{toDate}=today+14일`
                                    - Window 3: `{fromDate}=today+15일`, `{toDate}=today+21일`
                                    - Window 4: `{fromDate}=today+22일`, `{toDate}=today+28일`
    - 흐름: 여러 원천으로 수집한 정보를 하나의 형식([table.events] 테이블에 ticker, event_date, source)으로 통일하여 기록
        - POST /setEventsTable
            - 공통 요청 사양
                - Header
                    - `Content-Type: application/json`
                - Body
                    - 없음 (빈 JSON 허용)
                        - 이 엔드포인트는 입력 레코드를 받는 방식이 아니라 **DB 전체를 기준으로 배치 계산을 수행**하는 트리거 형태.
            - 요청 파라미터
                - overwrite (optional)
                    - type: boolean
                    - default: false
                    - rules:
                        - false: sector/industry가 NULL인 row만 업데이트
                        - true: sector/industry가 NULL이거나, ticker 매칭 시 [table.getTargets] 값과 불일치하는 row까지 모두 업데이트
                - dryRun (default=false)
                    - `true`이면 DB insert를 수행하지 않고, “탐지된 테이블 수/추가 예정 건수”만 반환한다.
                - schema (default='public')
                    - 탐색 대상 스키마. 기본은 `public`.
                - table (default=null)
                    - 탐색 대상 테이블을 ","로 구분하여 특정한다.
            - 기능
                - updateFromTable
                    - 목표: DB에서 테이블명이 evt_로 시작하는 모든 테이블을 자동 탐색하여 각 테이블의 (ticker, event_date)를 [table.events] 테이블의 ticker, event_date, source, source_id 값을 기록
                        - 모든 evt_* 테이블은 반드시 아래 컬럼을 가진다.
                            - id (uuid)
                            - ticker (text)
                            - event_date (timestamp/timestamptz)
                    - 기능
                        - evt_* 테이블 식별 기능
                            - 새로운 evt_* 테이블이 추가되어도 코드 수정 없이 자동 식별하여 정보 수집 대상으로 등록
                        - 기록 규칙
                            - [table.events] 테이블에 입력 컬럼 매핑
                                - `ticker` ← evt_*.ticker
                                - `event_date` ← evt_*.event_date
                                - `source` ← 원본 테이블명 (예: `evt_consensus`)
                                - `source_id` ← 원본 테이블의 id 값
                                - `sector`   ← [table.getTargets].sector
                                    - 매칭되지 않는 경우 NULL로 유지 (자동 보정 금지)
                                - `industry` ← [table.getTargets].industry
                                    - 매칭되지 않는 경우 NULL로 유지 (자동 보정 금지)
                            - 중복 방지
                                - `(ticker, event_date, source, source_id)` 조합이 이미 존재하면 **입력하지 않음**
                        - sector/industry 업데이트 규칙 (overwrite 파라미터 적용)
                            - 공통:
                                - ticker로 [table.getTargets]를 LEFT JOIN하여 sector/industry를 확보한다.
                                - [table.getTargets]에 ticker가 없으면 업데이트하지 않는다.
                            - overwrite=false (default):
                                - UPDATE 대상:
                                    - (`sector IS NULL OR industry IS NULL`) 인 row만
                                - 업데이트 내용:
                                    - sector/industry를 [table.getTargets] 값으로 채운다.
                            - overwrite=true:
                                - UPDATE 대상:
                                    - (`sector IS NULL OR industry IS NULL`)
                                    OR
                                    (ticker 매칭이 존재하고, 현재 값이 [table.getTargets] 값과 불일치)
                                - 불일치 판단:
                                    - `sector IS DISTINCT FROM targets.sector`
                                    OR
                                    `industry IS DISTINCT FROM targets.industry`
                                - 업데이트 내용:
                                    - sector/industry를 [table.getTargets] 값으로 강제 동기화한다.
                            - (금지)
                                - ticker가 매칭되지 않는데 임의의 sector/industry를 채우지 않는다.
                        - 동작 규칙
                            1. DB 메타데이터를 사용하여 `evt_%` 테이블 목록을 자동 조회한다.
                            2. 각 테이블에서 `id, ticker, event_date`를 조회한다.
                            3. [table.events] 테이블에 insert 한다.
                                - `ON CONFLICT (ticker, event_date, source, source_id) DO NOTHING`
                            4. [table.getTargets] 테이블에서 ticker별 sector/industry를 조회한다.
                            5. overwrite 규칙에 따라 [table.events]의 sector/industry를 UPDATE한다.
                                - overwrite=false:
                                    - NULL인 row만 업데이트
                                - overwrite=true:
                                    - NULL 또는 불일치 row 모두 업데이트
                        - 결과 반환
                            - 탐지된 evt_ 테이블 목록
                            - 테이블별 처리 건수
                                - 조회된 원본 row 수
                                - 신규 insert 수
                                - 중복으로 무시된 수
                                - 스킵된 테이블 및 사유(컬럼 누락 등)
                            - sector/industry 업데이트 집계
                                - sector_industry_updated: number
                                - sector_industry_skipped_no_target: number
                                - sector_industry_updated_mismatch: number
                                - sector_industry_updated_null: number
    - 흐름: POST /setEventsTable로 채워진 [table.events] 테이블 행들의 가치 평가 컬럼(value_quantitative, value_qualitative, position_quantitative, position_qualitative, disparity_quantitative, disparity_qualitative) 기록
        - POST /backfillEventsTable
            - 목표: [table.events] 테이블의 value_quantitative, value_qualitative, position_quantitative, position_qualitative, disparity_quantitative, disparity_qualitative 값을 채움
            - 요청 형식
                - Content-Type: `application/json`
                - Body: 없음(또는 빈 JSON 허용)
                    - 이 엔드포인트는 입력 레코드를 받는 방식이 아니라 **DB 전체를 기준으로 배치 계산을 수행**하는 트리거 형태.
            - 요청 파라미터
                - overwrite (default=false)
                    - overwrite=false
                        - [table.events] 테이블의 ticker, event_date, source 가 모두 null이 아닌 레코드 대상
                        - value_quantitative, value_qualitative, position_quantitative, position_qualitative 내부에서 null 인 값만 부분 갱신
                    - overwrite=true
                        - [table.events] 테이블의 ticker, event_date, source, response_key 가 모두 null이 아닌 경우
                        - value_quantitative, value_qualitative, position_quantitative, position_qualitative 값을 전체 갱신
            - 기능
                - valuation
                    a. 계산 시기 결정
                        - [table.events] 테이블의 event_date 값을 통해 해당하는 이벤트 시점을 기준으로 값을 수집하고 기록
                            - [table.events] 테이블에서 ticker는 서로 같은데 event_date 컬럼 값이 1년의 차이가 나는 경우 서로 다른 event_date 값을 기준으로 TTM, 직전 분기 등 유효한 범위의 값을 대상으로 해야 함
                            - 이러한 계산이 올바로 적용되었는지 확인이 가능하도록 [table.events] 테이블의 value_quantitative, value_qualitative jsonb 항목에 대상 기간에 대한 정보를 남겨야 함
                                - quantitative 계산 항목 중 4분기 정보로 계산하여야 하면서 값이 모두 확인된 경우
                                    {
                                        "ticker": "AAA",
                                        "event_date": "2023-01-11"
                                        ...
                                        "date_range": {
                                            "start": "2022-03-31",
                                            "end": "2022-12-31"
                                        },
                                        "calcType": "TTM_fullQuarter",
                                        "count": 4
                                    }
                                - quantitative 계산 항목 중 4분기 정보로 계산하여야 하면서 값이 일부만 확인된 경우
                                    {
                                        "ticker": "AAA",
                                        "event_date": "2021-07-04"
                                        ...
                                        "date_range": {
                                            "start": "2021-01-31",
                                            "end": "2021-06-30"
                                        },
                                        "calcType": "TTM_partialQuarter",
                                        "count": 3
                                    }
                                - quantitative 계산 항목 중 직전 1분기 정보로 계산하여야 하면서 값이 모두 확인된 경우
                                    {
                                        "ticker": "AAA",
                                        "event_date": "2021-02-08"
                                        ...
                                        "date_range": {
                                            "start": "2021-01-31",
                                            "end": "2021-01-31"
                                        },
                                        "calcType": "Last_full",
                                        "count": 1
                                    }
                                - quantitative 계산 항목 중 직전 1분기 정보로 계산하여야 하면서 값이 일부만 확인된 경우
                                    {
                                        "ticker": "AAA",
                                        "event_date": "2021-01-03"
                                        ...
                                        "date_range": {
                                            "start": "2020-12-31",
                                            "end": "2020-12-31"
                                        },
                                        "calcType": "Last_err",
                                        "count": 0
                                    }
                                - TTM (Trailing Twelve Months) 계산 방식:
                                    - 4개 분기 데이터가 모두 있으면: Q0 + Q1 + Q2 + Q3
                                    - 일부 분기 누락 시: (사용 가능한 분기 평균) × 4
                                    - 예: 3개 분기만 있으면 → (Q0 + Q1 + Q2) / 3 × 4
                    b. 가치 기록: 
                        - value_quantitative: [table.metric] 테이블의 domain 컬럼이 quantitative로 시작하는 경우에 대해 값을 계산하여 "-" 뒤에 있는 domain 키워드별로 묶어서 json 형식으로 value_quantitative에 기록하며, _meta의 sector와 industry의 경우 [table.getTargets] 테이블에서 일치하는 ticker의 값을 입력
                            - 출력 예시
                                {
                                "_meta": {
                                    "date_range": {
                                    "start": "2022-03-31",
                                    "end": "2022-12-31"
                                    },
                                    "calcType": "TTM_fullQuarter",
                                    "count": 4
                                },
                                "dilution": {
                                    "apicYoY": 0,
                                    "debtToEquityAvg": 0,
                                    "othernclToEquityAvg": 0
                                },
                                "risk": {
                                    "cashToRevenueTTM": 0,
                                    "currentRatio": 0,
                                    "netdebtToEquityAvg": 0,
                                    "runwayYears": 0
                                },
                                "valuation": {
                                    "evEBITDA": 0,
                                    "PBR": 0,
                                    "PER": 0,
                                    "PSR": 0
                                },
                                "momentum": {
                                    "grossMarginLast": 0,
                                    "grossMarginTTM": 0,
                                    "operatingMarginTTM": 0,
                                    "rndIntensityTTM": 0
                                },
                                "profitability": {
                                    "ROE": 0
                                }
                                }

                        - value_qualitative: [table.metric] 테이블의 domain 컬럼이 qualitative로 시작하는 경우에 대해 값을 계산하여 "-" 뒤에 있는 domain 키워드별로 묶어서 json 형식으로 value_qualitative에 기록
                            - consensusSignal (qualitative-consensusSignal)
                                - 목적
                                    - 컨센서스(Price Target) 이벤트(evt_consensus)의 "변화 신호"를 [table.events].value_qualitative에 정규화하여 저장한다.
                                    - 원천 API(raw)의 publishedDate/date 키를 직접 참조하지 않으며, 표준화된 event_date 및 evt_consensus 2단계 계산 결과(prev/direction)를 사용한다.

                                - 입력 소스(권위)
                                    - public.evt_consensus (2단계 계산 완료본)
                                        - 사용 컬럼:
                                            - ticker, event_date
                                            - analyst_name, analyst_company
                                            - price_target, price_when_posted
                                            - price_target_prev, price_when_posted_prev
                                            - direction
                                            - response_key.last (원천 row; meta 구성에 사용)
                                            - response_key.prev (원천 row; meta 구성에 사용 가능)
                                    - [table.events] 매칭 키(이벤트 행)
                                        - ticker = evt_consensus.ticker
                                        - source = 'evt_consensus'
                                        - source_id = evt_consensus.id
                                        - event_date = evt_consensus.event_date

                                - 생성 규칙(강제)
                                    - direction:
                                        - evt_consensus.direction 값을 그대로 사용한다. ("up" | "down" | null)
                                    - last:
                                        - last.price_target = evt_consensus.price_target
                                        - last.price_when_posted = evt_consensus.price_when_posted
                                    - prev:
                                        - prev.price_target = evt_consensus.price_target_prev
                                        - prev.price_when_posted = evt_consensus.price_when_posted_prev
                                        - prev 값이 없으면 prev = null 로 저장한다. (자동 보정 금지)
                                    - delta:
                                        - prev가 존재하는 경우에만 계산한다.
                                        - delta.price_target = last.price_target - prev.price_target
                                        - delta.price_when_posted = last.price_when_posted - prev.price_when_posted
                                    - deltaPct:
                                        - prev가 존재하고 prev.price_target 이 0/null 이 아닌 경우에만 계산한다.
                                        - deltaPct.price_target = delta.price_target / prev.price_target
                                    - meta:
                                        - meta.analyst_name = evt_consensus.analyst_name (nullable)
                                        - meta.analyst_company = evt_consensus.analyst_company (nullable)
                                        - 원천 뉴스 정보는 evt_consensus.response_key.last 에서 가능한 경우에만 복사한다.
                                        (예: newsURL, newsTitle, newsPublisher, newsBaseURL)
                                        - 불일치 발견 시 자동 보정하지 않는다. (사용자 확인 후 결정)
                                - 주의사항(원칙 준수)
                                    - evt_consensus 1단계 Raw Upsert 단계에서는 consensusSignal 생성에 필요한 prev/direction이 완성되지 않으므로,
                                    반드시 2단계 계산 완료 이후에 [table.events] 업데이트를 수행한다.
                                    - DB 스키마/제약과 충돌 가능성이 발견되면 DB를 최종 권위로 따르고,
                                    warn에 'POLICY_CONFLICT_DB_SCHEMA' 를 기록한다.
                                - 저장 위치 및 형태(예시)
                                    - [table.events].value_qualitative 내 "consensusSignal" 키로 저장한다.
                                    - 출력 예시
                                        ```json
                                        {
                                        "targetMedian": 0,
                                        "consensusSummary": {
                                            "targetLow": "targetLow",
                                            "targetHigh": "targetHigh",
                                            "targetMedian": "targetMedian",
                                            "targetConsensus": "targetConsensus"
                                        },
                                        "consensusSignal": {
                                            "source": "evt_consensus",
                                            "source_id": "7f5b7a2a-9e1f-4d7b-9d52-6b3f5f5a0d0a",
                                            "event_date": "2025-12-08T00:00:00Z",
                                            "direction": "up",
                                            "last": {
                                            "price_target": 210.0,
                                            "price_when_posted": 198.5
                                            },
                                            "prev": {
                                            "price_target": 190.0,
                                            "price_when_posted": 185.2
                                            },
                                            "delta": {
                                            "price_target": 20.0,
                                            "price_when_posted": 13.3
                                            },
                                            "deltaPct": {
                                            "price_target": 0.1052631579
                                            },
                                            "meta": {
                                            "analyst_name": "John Doe",
                                            "analyst_company": "ABC Securities",
                                            "news_url": "https://...",
                                            "news_title": "....",
                                            "news_publisher": "....",
                                            "source_api": "fmp-price-target"
                                            }
                                        }
                                        }
                                        ```
                        - position_quantitative: [table.metric] 테이블의 priceQuantitative인 값이 [table.metric] 테이블의 price 값보다 작다면 short, 크다면 long
                            - 출력 예시
                                "long" | "short" | "undefined"
                        - disparity_quantitative: {([table.metric] 테이블의 priceQuantitative인 값) / ([table.metric] 테이블의 price 값)} - 1 값 기록
                            - 출력 예시
                                -0.2
                        - position_qualitative: [table.metric] 테이블의 priceQualitative인 값이 [table.metric] 테이블의 price 값보다 작다면 short, 크다면 long
                            - 출력 예시
                                "long" | "short" | "undefined"
                        - disparity_qualitative: {([table.metric] 테이블의 priceQualitative인 값) / ([table.metric] 테이블의 price 값)} - 1 값 기록
                            - 출력 예시
                                0.5
                - priceTrend
                    - [권장] price_trend 저장 대상은 [table.events]로 단일화한다.
                        - [사유] 문서 내에서 [table.events]와 별도 테이블명이 혼재되면(fillAnalyst/backfillEventsTable) 로딩 경로가 불안정해짐.
                        - [사유] tables.ini에는 [table.events].price_trend가 정의되어 있으므로, 존재가 불확실한 별도 테이블명 사용을 지양.
                    - 목표: [table.events] 테이블의 price_trend 값을 채움
                    - 기능
                        - 배치 입력 수신
                            - 여러 대상을 한 번에 등록
                            - 입력 레코드 최소 스키마(필수)
                                - { ticker, source, event_date, source_id }
                        - 입력 검증
                            - ticker/source/event_date/source_id 규칙 확인
                                - `ticker` ← [table.getTargets].ticker에 존재하는 값
                                - `source` ← 원본 테이블명 (예: `evt_consensus`)
                                    - source는 (evt_*) 실제 존재 테이블 목록 또는 config에 정의된 허용 source 목록 중 하나여야 함
                                        - source 검증 기준(권장)
                                            - DB 메타데이터에서 `public.evt_%` 패턴으로 **실제 존재하는 테이블명** 목록을 조회하여 포함 여부를 검증한다.
                                - `event_date` ← ISO 8601 timestamp (timezone 포함 권장, 예: `2025-12-09T00:00:00Z`)
                                    - event_date 비교 규칙(정규화 없이 “날짜값”만 사용, 이미 timezone 포함 형식으로 저장하도록 되어 있음)
                                        - 저장된 event_date의 timestamp 자체는 변경/정규화하지 않는다.
                                        - 다만, row 식별 및 업데이트 대상 매칭은 **날짜(date) 파트만** 비교한다.
                                            - 비교 기준 timezone은 **UTC** 로 한다.
                                            - 예: `(event_date AT TIME ZONE 'UTC')::date = (:event_date AT TIME ZONE 'UTC')::date`
                                        - 단일성(모호성 방지) 규칙
                                            - (ticker, source, source_id, event_day_ts[timestamptz])가 입력되더라도,
                                              매칭은 (ticker, source, source_id, event_day_utc_date)로 수행한다.
                                                - event_day_utc_date := (:event_date AT TIME ZONE 'UTC')::date
                                            - (ticker, source, source_id, event_day_utc_date) 조합으로 매칭되는 [table.events] row는 **반드시 1개**여야 한다.
                                            - 0개면 실패(EVENT_ROW_NOT_FOUND), 2개 이상이면 실패(AMBIGUOUS_EVENT_DATE).
                                - `source_id` ← 원본 테이블(evt_*)의 레코드 식별자(예: evt_consensus.id 또는 source row의 pk/unique key)
                        - 가격 입력 틀 생성
                            - config_lv0_policy.function 값이 fillPriceTrend_dateRange인 행의 policy 컬럼에 있는 countStart 값과 countEnd 값을 각각 event_date에 더한 값이 수집 대상 범위 기간이 됨
                                - event_date=2025-12-09, countStart=-14, countEnd=14일때 수집 기간 범위는 2025-11-19~2025-12-29
                                - countStart와 countEnd는 거래일을 의미함
                                - **거래일 기준**
                                    - 주말 및 NASDAQ 휴장일 자동 스킵
                                        - event_date=2025-12-12(금), ... , D-5=2025-12-05(금), D-4=2025-12-08(월), ... , D+1=2025-12-15(월), ...
                                    - 휴장일은 [table.getHolidays] 테이블의 내용 참고
                                    - **Progressive Null-Filling**
                                        - 미래 거래일의 정보는 `null` 저장
                                        - 미래/과거 판정 기준
                                            - 기준일은 **UTC 기준 오늘 날짜**(또는 “미국시장 최근 거래일”로 운영 정책이 있다면 그 날짜)로 한다.
                                            - targetDate가 기준일 이후인 경우 OHLC는 null로 유지한다.
                                - dayOffset 정의
                                    - dayOffset는 `countStart`부터 `countEnd`까지 **0 포함**하여 생성한다.
                                    - event_date가 비거래일인 경우 dayOffset=0의 targetDate는 **직후 첫 거래일**로 매핑한다. (예: 토/일/휴장일 → 다음 거래일)
                                - 휴장일/거래일 기준
                                    - 휴장일 기준 시장은 [table.getHolidays]에 정의된 **미국 주식시장 캘린더(NASDAQ/NYSE 공통)** 를 따른다.
                                    - 날짜 연산(거래일 판정 포함)의 기준 timezone은 **UTC** 로 한다.
                            - 위 조건에 맞게 [table.events] 테이블의 price_trend 컬럼에 아래의 형식으로 스키마를 구성
                                [
                                    {
                                        "low": null,
                                        "high": null,
                                        "open": null,
                                        "close": null,
                                        "dayOffset": -14,
                                        "targetDate": "2025-11-19"
                                    },
                                    {
                                        "low": null,
                                        "high": null,
                                        "open": null,
                                        "close": null,
                                        "dayOffset": -13,
                                        "targetDate": "2025-11-20"
                                    },
                                    ...
                                    {
                                        "low": null,
                                        "high": null,
                                        "open": null,
                                        "close": null,
                                        "dayOffset": 14,
                                        "targetDate": "2025-12-29"
                                    }
                                ]
                        - 가격 이력 수집
                            - [table.metric].priceEodOHLC로 API를 호출하여 각 거래일의 OHLC 조회
                                - 조회시 ticker가 같고, 기간이 여러개라면 하나의 티커에 대해 모든 기간을 커버하는 범위의 날짜로 api를 호출하여 단 1번의 호출로 하나의 ticker의 모든 기간 OHLC를 기록해야 함
                                    - 조회 기간 산출 (policy 기반; 강제)
                                        - config_lv0_policy.function 값이 priceEodOHLC_dateRange 인 행의 policy 컬럼에 있는 countStart 값과 countEnd 값을 unique ticker가 가진 event_date 범위(min/max)에 적용하여 OHLC 수집 기간(from/to)을 결정한다.
                                            - fromDate = (min_event_date + countStart)
                                            - toDate   = (max_event_date + countEnd)
                                        - countStart와 countEnd는 달력일(day) 기준 오프셋을 의미한다.
                                            - 예시: min_event_date=2022-12-10, max_event_date=2025-10-11, countStart=-30, countEnd=31
                                                - 수집 기간: 2022-11-10 ~ 2025-11-11
                                    - 예시
                                        ticker/source/event_date
                                        aaa/evt_earnings/2021-10-11
                                        aaa/evt_earnings/2025-12-08
                                        rgti/evt_consensus/2025-10-11
                                        rgti/evt_earnings/2022-12-10                    

                                        대상이 위와 같이 4개인 경우 unique한 ticker는 2개, 
                                        [table.metric].priceEodOHLC로 호출할 api는 아래의 2개
                                        https://financialmodelingprep.com/stable/historical-price-eod/full?symbol=rgti&from=2022-11-10&to=2025-11-11&apikey=8AP6lUDNsrBwtx5IzVoDliKnG186rBSt
                                        https://financialmodelingprep.com/stable/historical-price-eod/full?symbol=aaa&from=2021-09-11&to=2026-01-08&apikey=8AP6lUDNsrBwtx5IzVoDliKnG186rBSt

                            - 값 입력
                                - 입력값(ticker/source/event_date/source_id)을 사용하여 [table.events]에서 업데이트 대상 row를 매칭한다.
                                    - source_id ← 원본 테이블(evt_*)의 레코드 식별자(예: evt_consensus.id 또는 source row의 pk/unique key)
                                - [table.events] 테이블의 price_trend 컬럼에 schema 형식으로 값을 입력
                                    [
                                        {
                                            "low": 57.72,
                                            "high": 58.56,
                                            "open": 58.42,
                                            "close": 58.1,
                                            "dayOffset": -14,
                                            "targetDate": "2025-11-19"
                                        },
                                        {
                                            "low": 57.15,
                                            "high": 59.09,
                                            "open": 58.69,
                                            "close": 57.6,
                                            "dayOffset": -13,
                                            "targetDate": "2025-11-20"
                                        },
                                        ...
                                        {
                                            "low": null,
                                            "high": null,
                                            "open": null,
                                            "close": null,
                                            "dayOffset": 14,
                                            "targetDate": "2025-12-29"
                                        }
                                    ]
                        - DB 저장 (update-only)
                            - `[table.events]` 테이블에 가격 이력 저장
                            - Update 정책 (행이 없으면 FAIL)
                                - 대상 입력 식별자: (ticker, source, source_id, event_date[timestamptz])
                                - 매칭 기준 키: (ticker, source, source_id, event_day_utc_date)
                                    - event_day_utc_date := (event_date AT TIME ZONE 'UTC')::date
                                - 선행 조건:
                                    - 해당 키의 row는 **반드시** `/setEventsTable` 또는 `/backfillEventsTable`에 의해 사전에 생성되어 있어야 한다.
                                - 동작:
                                    - 동일 키의 row가 **존재하면** `price_trend`를 업데이트한다.
                                    - 동일 키의 row가 **존재하지 않으면** **실패 처리**한다.
                                    - 실패 판단 기준: 
                                        - 매칭 규칙(날짜 비교)으로 row를 탐색했을 때
                                            - 매칭 0건이면 실패 처리한다. (error_code: `EVENT_ROW_NOT_FOUND`)
                                            - 매칭 2건 이상이면 실패 처리한다. (error_code: `AMBIGUOUS_EVENT_DATE`)
                                        - `UPDATE` 수행 결과 **affected rows = 0** 인 경우에도 실패 처리한다. (error_code: `EVENT_ROW_NOT_FOUND`)
                            - 저장 기준(구현 힌트)
                                - (권장) 2단계: (1) 단건 id 조회 → (2) id로 update
                                - 예시 SQL(단건 보장 조회)
                                    - `SELECT id FROM public.[table.events]
                                       WHERE ticker=:ticker
                                         AND source=:source
                                         AND source_id=:source_id
                                         AND (event_date AT TIME ZONE 'UTC')::date = (:event_date AT TIME ZONE 'UTC')::date;`
                                - 예시 SQL(업데이트)
                                    - `UPDATE public.[table.events] SET price_trend = :price_trend WHERE id=:id;`
                                - (대안) 1단계 update(단, 다건 매칭 차단 로직을 반드시 선행)
                                    - `UPDATE public.[table.events]
                                       SET price_trend = :price_trend
                                     WHERE ticker=:ticker
                                       AND source=:source
                                       AND source_id=:source_id
                                       AND (event_date AT TIME ZONE 'UTC')::date = (:event_date AT TIME ZONE 'UTC')::date;`
                        - 결과 반환
                            - **HTTP 207 Multi-Status**
                            - 각 레코드별 성공/실패 상태를 개별 반환
                            - summary로 총 성공/실패 집계 제공
                            - 실패 레코드 최소 응답 필드(권장)
                                - { ticker, source, event_date, source_id, status, error_code, message }
    - 흐름: backfillEventsTable로 채워진 [table.events] 테이블 행들 중 source 컬럼 값이 "evt_consensus"인 행들의 value_qualitative.meta.analyst_name, value_qualitative.meta.analyst_company 값이 같은 값들의 priceTrend을 묶어 priceTrend.dayOffset 별로 성과를 기록한 테이블을 생성
        - POST /fillAnalyst
            - 요청 형식
                - Content-Type: `application/json`
                - Body: 없음(또는 빈 JSON 허용)
                    - 이 엔드포인트는 입력 레코드를 받는 방식이 아니라 **DB 전체를 기준으로 배치 계산을 수행**하는 트리거 형태.

            - 요청 파라미터(필드) 검증 규칙
                - 입력 필드 기반 검증은 없으며, 아래는 **실행 전/중 내부 점검(Validation/Guard) 규칙**으로 정의

            - 정책 존재 여부
                - `config_lv0_policy.function = fillPriceTrend_dateRange` 인 정책이 존재해야 함
                - 에러: `POLICY_NOT_FOUND`

            - 정책 파싱 가능 여부
                - `policy` 컬럼 내 `countStart`, `countEnd` 파싱 실패 시
                - 에러: `INVALID_POLICY`

            - Analyst 식별자(키) 유효성 규칙 (generated key 적용)
                - `analyst_name`, `analyst_company`는 각각 **NULL일 수 있음**
                - 단, **둘 다 NULL인 경우는 분석/기록 대상에서 제외**(원칙)
                - `(analyst_name IS NULL AND analyst_company IS NULL)` 인 이벤트는 **스킵**
                - 해당 스킵 건은 결과 summary에 집계(예: `events_skipped_both_null_analyst`)
                - 그룹 키는 원본 키(analyst_name, analyst_company)로 구성하되, upsert 충돌 키는 아래 generated key를 사용한다.
                - `analyst_name_key = coalesce(analyst_name,'__NULL__')`
                - `analyst_company_key = coalesce(analyst_company,'__NULL__')`
                - 즉, (NULL 포함) 동일 조합은 항상 동일 key로 합쳐져 **중복 row 생성이 방지**된다.

            - 이벤트 기반 priceTrend 범위 검증
                - 본 엔드포인트는 [table.events] 테이블의 `source='evt_consensus'` 이벤트 행들에 대해 **priceTrend가 fillPriceTrend_dateRange 정책 기준(dayOffset: countStart~countEnd)으로 이미 채워져 있음**을 전제로 함.
                - 따라서 각 이벤트 레코드의 `event_date` 기준 `countStart~countEnd` **dayOffset 스키마가 누락 없이 존재하는지 점검**
                - 불일치/누락 시 에러: `INVALID_PRICE_TREND_RANGE`

            - 분석 대상 컬럼 존재/유효성 (이벤트 기준)
                - 대상: `[table.events]` 테이블 중 `source='evt_consensus'`
                - 필수:
                - `value_qualitative.meta.analyst_name` (NULL 허용)
                - `value_qualitative.meta.analyst_company` (NULL 허용)
                - 단, 위 2개가 **모두 NULL이면 제외(스킵)**
                - `event_date` (이벤트 기준일: 저장 위치가 event_date/별도 필드일 경우 해당 컬럼으로 매핑)
                - `price_when_posted` (변동률 기준 값: 저장 위치가 [table.events].value_qualitative.consensusSignal.last.price_when_posted 값을 매핑)
                - `priceTrend` (dayOffset별 가격/수익률 시계열: 저장 위치는 시스템 정의에 따름)
                - 필수값 대량 누락 등 처리 불가 수준이면
                - 에러: `INVALID_CONSENSUS_DATA`

            - 분석 메트릭 정의 존재 여부
                - `[table.metric].domain = internal(qual)` 에 성과 계산에 필요한 메트릭 정의가 존재해야 함
                - 미존재 시 에러: `METRIC_NOT_FOUND`

            - 기능
            1) 전체 데이터 로드 (이벤트 기준)
                - `[table.events]` 테이블에서 아래 조건을 만족하는 행 전체 조회
                - `source = 'evt_consensus'`
                - `(value_qualitative.meta.analyst_name IS NOT NULL OR value_qualitative.meta.analyst_company IS NOT NULL)`
                    - 둘 다 NULL인 경우는 조회/처리 대상에서 제외(스킵 원칙)
                - `priceTrend` 존재

            2) Analyst 단위로 그룹핑 (generated key 반영)
                - 그룹 키(논리): `(analyst_name, analyst_company)` (각각 NULL 허용, 단 둘 다 NULL 금지)
                    - generated key (analyst_name_key, analyst_company_key)는 [table.analyst] upsert 및 analyst 단위 집계에만 적용한다.
                    - evt_consensus, [table.events] 등 이벤트 단위 테이블에는 적용하지 않는다.
                - upsert 충돌 키(물리): `(analyst_name_key, analyst_company_key)`
                    - `analyst_name_key = coalesce(analyst_name,'__NULL__')`
                    - `analyst_company_key = coalesce(analyst_company,'__NULL__')`
                - 그룹 키별로 `[table.analyst]` 테이블에 아래의 값을 입력/갱신
                    - `analyst_name` (nullable)
                    - `analyst_company` (nullable)
                    - `analyst_name_key`, `analyst_company_key` (generated key; upsert 기준)
                - 단, 둘 다 NULL인 행은 생성/업데이트하지 않음

            3) performance 컬럼 스키마 생성/점검
                - `config_lv0_policy.function = fillPriceTrend_dateRange` 인 행의
                `policy.countStart`, `policy.countEnd`를 성과 집계 범위(dayOffset)로 사용
                - 이 기준에 맞춰 이벤트의 `priceTrend`가 이미 채워져 있으므로,
                정책 범위에 맞는 dayOffset 스키마가 **모든(처리 대상) 이벤트에 대해** 존재하는지 점검한다.

            4) dayOffset별 변동률 분포 생성
                - 각 Analyst 그룹에 대해:
                - 그룹에 속한 이벤트들의 priceTrend를 결합하여 dayOffset별 분포(표본 집합) 생성
                - 변동률(수익률) 표준 정의(강제)
                    - `basePrice := [table.events].value_qualitative.consensusSignal.last.price_when_posted`
                    - `close := [table.events].price_trend[dayOffset].close`
                    - `return := (close / basePrice) - 1`
                - 규칙:
                    - 미래 구간은 null 처리 허용
                    - `close = null` 또는 `basePrice is null/0` 인 표본은 통계 계산에서 제외 (자동 보정 금지)
                    - dayOffset별 `count`는 통계에 포함된 유효 표본 수로 기록

            5) internal(qual) 메트릭 규칙에 따라 통계 계산 및 performance 채움 (DB 정의 권위; 강제)
                - 계산 로직 하드코딩 금지:
                    - Mean/Median/p25/p75/stddev/CI/proficiency 등을 코드에 직접 구현하지 않는다.
                    - 반드시 `public.[table.metric]` 정의를 해석하여 산출한다.
                - 적용 대상(강제):
                    - `public.[table.metric].domain = 'internal(qual)'`
                - 입력 분포(강제):
                    - 4)에서 생성된 return 분포(dayOffset별 표본 집합)
                - 메트릭 선택 규칙(강제):
                    - `base_metric_id = 'priceTrendReturnSeries'` 인 메트릭만 사용
                - performance 필드 매핑(강제):
                    - Mean               ← returnMeanByDayOffset
                    - Median             ← returnMedianByDayOffset
                    - 1stQuartile        ← returnFirstQuartileByDayOffset
                    - 3rdQuartile        ← returnThirdQuartileByDayOffset
                    - InterquartileRange ← returnIQRByDayOffset
                    - standardDeviation  ← returnStdDevByDayOffset
                    - count              ← returnCountByDayOffset
                - ConfidenceInterval:
                    - return CI 메트릭 정의가 있을 때만 채움
                - ProficiencyRate:
                    - return ProficiencyRate 메트릭 정의가 있을 때만 채움
                - 충돌 시:
                    - DB 정의를 최종 권위로 적용하고 `warn += ['POLICY_CONFLICT_DB_SCHEMA']` 기록

            6) `[table.analyst]` upsert (generated key 기준)
                - upsert conflict key:
                - `(analyst_name_key, analyst_company_key)`
                - 둘 다 NULL인 경우는 upsert 수행하지 않음(원천에서 제외됨)

            7) 207(HTTP 상태 코드 207 Multi-Status)로 그룹별 결과 + summary 반환
                - summary에 아래 항목을 포함 권장
                - `total_events_loaded`
                - `events_skipped_both_null_analyst`
                - `total_groups`
                - `groups_success`
                - `groups_failed`
                - `groups_skipped` (필요 시)
                - `errors_by_code` (집계)

            - performance 기본 스키마(값 초기 형태)
            ```json
            [
                {
                "dayOffset": -14,
                "Mean": null,
                "Median": null,
                "1stQuartile": null,
                "3rdQuartile": null,
                "InterquartileRange": null,
                "standardDeviation": null,
                "ConfidenceInterval": null,
                "ProficiencyRate": null,
                "count": null
                },
                ...
                {
                "dayOffset": 14,
                "Mean": null,
                "Median": null,
                "1stQuartile": null,
                "3rdQuartile": null,
                "InterquartileRange": null,
                "standardDeviation": null,
                "ConfidenceInterval": null,
                "ProficiencyRate": null,
                "count": null
                }
            ]
            ```

            - 에러 코드 정의(권장)
            - fillPriceTrend_dateRange 정책 미존재
                - 에러: POLICY_NOT_FOUND
            - policy JSON 파싱 실패 또는 countStart/countEnd 이상
                - 에러: INVALID_POLICY
            - 필수 컬럼 누락/비정상 데이터로 계산 불가 (이벤트 기반)
                - 에러: INVALID_CONSENSUS_DATA
            - event_date 기준 정책 범위 dayOffset 누락/불일치 (이벤트의 priceTrend 범위 검증)
                - 에러: INVALID_PRICE_TREND_RANGE
            - internal(qual) 메트릭 정의 미존재
                - 에러: METRIC_NOT_FOUND
            - 기타 서버 내부 오류
                - 에러: INTERNAL_ERROR

            - 처리 요약(Flow)
            1. `fillPriceTrend_dateRange` 정책 로드 및 범위 확인
            2. `[table.events]`에서 `source='evt_consensus'` 이벤트 전체 로드
                - 단, (analyst_name IS NULL AND analyst_company IS NULL) 이벤트는 제외(스킵)
            3. `(analyst_name, analyst_company)`로 그룹핑 (NULL 허용, 단 둘 다 NULL 금지)
                - upsert는 generated key `(analyst_name_key, analyst_company_key)` 기준
            4. 각 그룹에 대해
                - priceTrend dayOffset 스키마 정책 일치성 점검
                - `price_when_posted` 대비 dayOffset별 변동률 분포 생성
                - internal(qual) 메트릭 규칙에 따라 통계 계산
                - performance 채움
            5. `[table.analyst]` upsert
            6. 207로 그룹별 결과 + summary 반환

            - 구현 시 주의사항(권장)
            - 미래 구간 null 처리
            - `priceTrend.close = null` 인 dayOffset은 통계 계산에서 제외
            - dayOffset별 `count`로 데이터 성숙도 확인 가능
            - 정책 변경에 대한 안전장치
                - `fillPriceTrend_dateRange`의 countStart/countEnd 변경 시 기존 이벤트의 priceTrend와 불일치가 발생할 수 있으므로 본 엔드포인트에서 반드시 범위 검증 수행
                - (금지) 불일치 발견 시 자동 보정/재생성하지 않는다. 정책-데이터 불일치로 간주하고 INVALID_PRICE_TREND_RANGE로 실패 처리한다.
            - 대용량 처리
                - analyst 그룹 수/이벤트 수가 많을 경우
                - 스트리밍/배치 chunk 처리
                - 그룹별 계산 후 upsert 단위 최소화 권장
---
- 라우터별 기능
    - control (기능과 설정값에 대한 설명, 설정이 가능한 페이지)
        - 환경변수 (암호화)
            - AES-256-GCM 암호화: FMP_API_KEY, CONTROL_API_KEY, SUPABASE 정보 등 민감한 데이터를 암호화하여 저장
            - 안전한 관리: config/env.encrypted.json에 암호화된 상태로 저장
            - 실시간 조회: 👀 버튼으로 복호화된 값 확인 (마스킹 처리)
            - 추가/수정/삭제: 환경변수를 브라우저에서 직접 관리
        - API 호출 최적화
            - `엔드포인트 구현시 준수 사항`의 `경제적 호출` 지침에 대한 최적화 변수 관리
        - 기준 시간 설정
            - 서비스 내에 사용되는 모든 시간의 기준을 변환하는 기능
                - 수신하는 시간값을 입력한 값으로 변경
                - 이미 DB의 모든 테이블에 존재하는 날짜 관련 컬럼, jsonb 내부의 값들을 업데이트
        - 스케줄러
            - Cron 표현식: 주기적으로 실행할 작업의 스케줄 설정
            - 시간대 설정: 미국 시장 시간(America/New_York) 기준 스케줄 관리
            - 활성화/비활성화: 개별 스케줄 작업을 켜고 끌 수 있음
            - sourceData 엔드포인트의 getHolidays, getTicker, getConsensus 기능에 어떤 날짜에 어떤 기간을 가지고 업데이트할지 설정
                - sourceData 엔드포인트에 기능이 늘어나면 값을 별도의 코드 추가 없이 config_lv0_policy 테이블의 function이 sourceData_dateRange인 값의 policy 값이 업데이트되고, dashboard에 값을 입력할 수 있도록 함
                - config_lv0_policy 테이블의 function이 sourceData_dateRange인 값의 policy 스키마
                    {
                    "getTarget": {
                        "type": "cycle",          // type 값이 cycle인 경우 value 만큼의 날짜 후에 값을 업데이트함
                        "value": 7,               // type 값이 cycle인 경우 value 만큼의 날짜 후에 값을 업데이트함
                        "status": true            // 자동 업데이트의 활성화 여부 (true=활성, false=비활성)
                    },
                    "getHoliday": {
                        "type": "weekly",         // type 값이 weekly 경우 value에 지정된 요일에 값을 업데이트함
                        "value": ["MON", "WED"],  // type 값이 weekly 경우 value에 지정된 요일에 값을 업데이트함
                        "status": true
                    },
                    "getConsensus": {
                        "type": "cycle",
                        "value": 1,
                        "status": false
                    }
                    }
        - 배치 처리
            - 동시 처리 수: 한 번에 몇 개의 요청을 병렬로 처리할지 설정
            - 배치 크기: 대량 데이터를 몇 개씩 묶어서 처리할지 결정
                - DB_UPSERT_BATCH_SIZE: DB 저장 배치 크기는 1000개 여야 함
            - 재시도 정책: 실패 시 몇 번까지 재시도할지, 간격은 얼마나 둘지 설정
            - 타임아웃: 요청이 얼마나 오래 걸리면 실패로 처리할지 지정
    - requests
        - API Status (스크롤 관계 없이 하단 고정)
            - API Status UI는 화면의 20% 수준의 영역을 차지 함
            - API Status 기능 내의 상단 상태바 (컴팩트하게 구성하는 것이 원칙)
                - 맨 위 한 줄
                    - 좌측부터 사용중인 상태명과 현재값 표시: 서비스에 존재하는 모든 API의 로그별 상태명값(Elapsed, progress, timeLeft, Rate, Mode, batchSize 등을 여러 컬럼으로 나누어 출력)을 호출된 API에 맞게 출력, 평소에는 null 혹은 직전 출력값(상태명 값은 출력하면서 확인하는 것이 아닌, 사용 API의 로그를 미리 확인하고 준비할 것)
                        - 예시
                            - 사용중인 API가 [endpoint phase name] Elapsed: 5s | progress: 50/4451 (1%) | timeLeft: 495s (500s-5s) | Rate: 45/250 | Mode: Aggressive (usage < 30%) | batchSize: 50 (250*0.2)를 로그에 출력중이라면
                                - Elapsed, progress, timeLeft, Rate, Mode, batchSize를 식별하여 상태바에 출력하고 각각의 값들도 함께 출력
                            - 사용중인 API가 [endpoint phase name] success: 20 | fail: 50 | skip: 36 | update: 3352 를 로그에 출력중이라면
                                - success, fail, skip, update를 식별하여 상태바에 출력하고 각각의 값들도 함께 출력
                    - 맨 우측 정렬로 취소 버튼: 중단 제어
                    - 취소 버튼 좌측에 현재 상태 표시: 현재 작업 상태 및 진행률 바 표시
                - 두 번째 한 줄
                    - 좌측부터 80% 지점까지 진행률 바 표시
                    - 맨 우측 예상 완료 시간과 진행% 표시 (ETA): 현재 속도 기반 작업 완료 예상 시간 (`API 호출 최적화` 내용 참고)
                - 나머지 영역
                    - 실시간 로그: 각 거래의 처리 결과 메시지 스트리밍

        - 모든 엔드포인트와 하위 파라미터들에 대해 간편 요청을 하고 호출 및 출력 상태에 대해 API Status 요소에 출력될 수 있도록 함
            - 파일 업로드 지원
                - 지원 형식: CSV, TSV, JSON, TXT (탭 구분 텍스트)
                - 드래그 앤 드롭: 파일을 박스에 드래그하거나 클릭하여 선택
                - 자동 파싱: 파일 형식을 자동 감지하여 데이터 추출
                - 필수 컬럼: 엔드포인트에 따라 다름
            - 직접 입력 지원
                - 탭 구분 형식: 엑셀에서 복사한 데이터를 바로 붙여넣기 가능
                - 헤더 자동 감지: 첫 줄을 헤더로 인식하거나 생략 가능
                - 실시간 검증: 입력하면서 즉시 포맷 오류 확인
                - 예시 제공: placeholder에 입력 형식 샘플 표시
            - 미리보기 지원
                - 데이터 검증: 등록 전 모든 거래 데이터 확인
                - 오류 표시: 잘못된 형식이나 누락된 정보 강조
                - 편집 가능: 미리보기에서 직접 수정 후 전송
                - 건수 표시: 총 몇 건의 거래가 등록되는지 확인
            - 진행 상태와 결과는 API Status에서 출력
    - conditionGroup
        - 목표: [table.events]의 컬럼별롤 각 항목을 드롭다운으로 선택할 수 있도록 해야 하고 컬럼과 항목의 조합에 따라 [table.events].condition 컬럼에 항목을 일괄 Create(생성), Read(읽기), Update(갱신), Delete(삭제)할 수 있는 페이지
            0. 이미 존재하는 그룹을 선택하여 수정할 수 있음
            1. 그룹핑할 컬럼 선택
            2. 해당 컬럼의 항목을 드롭다운으로 선택
            3. 해당 조합의 이름을 입력할 수 있는 인풋값 입력 (이미 해당 조합으로 지정된 이름이 있다면 수정, 삭제 가능)
            - 예시
                - source가 evt_consensus이고, sector가 Financial Services인 경우를 필터링하여 conFS라고 입력한 경우 [table.events] 테이블의 source가 evt_consensus이고, sector가 Financial Services인 행들의 condition 컬럼에 conFS가 입력됨
    - dashboard
        - 목표: [table.events]의 어떤 컬럼(source, sector, industry, condition, ... (추후 컬럼 확장에 따라 확장 가능))의 각 컬럼의 어떤 항목(evt_consensus, evt_earning, Financial Services, ... (추후 항목 확장에 따라 확장 가능))이 price_trend의 코호트(서로 다른 행들의 동일 dayOffset N값의 성과(dayOffset 0 대비 dayOffset N값))의 성과가 가장 좋은지 확인하기 위해 조건별 성과와 추이를 표의 형태로 확인할 수 있어야 함