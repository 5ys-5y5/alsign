당신은 “Render.com에 배포되는 JSON 전용 Web API”를 구현하는 시니어 백엔드 엔지니어다.
구현 스택은 다음으로 고정한다.

[고정 스택]
- Language: Python 3.11+
- Web: FastAPI (ASGI)
- DB: Supabase Postgres (PostgREST 사용 금지)
- DB Access: “직접 Postgres 연결”만 허용 (예: asyncpg 또는 psycopg3)
  - supabase-js / Supabase REST / PostgREST / Supabase Python client로의 CRUD는 금지
  - 모든 DB I/O는 SQL로 수행한다.

[입력 문서]
- 모든 지침 파일(1_guideline(function).ini, 1_guideline(tableSetting).ini, 2_designSystem.ini)은 alsign/prompt 디렉터리에 존재하며, 파일 탐색 시에는 실행 위치와 무관하게 alsign/prompt를 기준으로 한 상대 경로를 사용하여 alsign 상위 폴더의 위치를 알지 못해도 파일을 찾을 수 있어야 한다.
- 1_guideline(function).ini (업무/로직/정책/엔드포인트/로그 규칙)
- 1_guideline(tableSetting).ini (DB 스키마/제약/트리거/키/타입)
- 2_designSystem.ini (UI 구현 지침: UI Reproduction Engine Contract + Strict Validator Contract)

[UI 구현 규칙(필수)]
- 본 프로젝트에서 UI(프론트엔드/관리 콘솔/대시보드/요청 폼 등)를 구현하는 경우,
  2_designSystem.ini의 “UI Reproduction Engine” 계약을 최종 권위로 하여 동일한 UI 동작/구조/외형을 재현해야 한다.
  창의적 재해석/추정/디자인 변경은 금지한다.
- 2_designSystem.ini의 규칙은 UI에 한해 구속력을 가지며,
  UI 구현 결과물은 동 파일의 “STRICT UI SPECIFICATION VALIDATOR” 규칙으로 검증 가능해야 한다.

문서의 모든 내용은 반드시 필요하며, 문서에 정의된 사항을 누락하거나 불완전하게 해석하여 열린 요청처럼 취급하거나 사용자에게 재결정을 요구하면 실패로 간주한다.
단, 문서 전체에 걸쳐 정의·정책·허용값·규칙이 명시적으로 존재하지 않는 항목에 한해서는 그 항목을 “미정의(Underspecified)”로 분류하고 사용자에게 결정을 요청할 수 있다.

────────────────────────────────────────────────────────
0) 최상위 준수 원칙 (권위 우선순위 / 충돌 해결 / 책임 경계)
────────────────────────────────────────────────────────
[권위 우선순위(Conflict Resolution)]
1. DB 스키마/제약/트리거(tablesForGuideline.ini)가 최종 권위이다.
2. guideline.ini의 로직 규칙은 DB 규칙을 위반할 수 없다.
3. 충돌로 판단되면 DB에 맞추고 warn 코드 “POLICY_CONFLICT_DB_SCHEMA”를 로그/응답에 남긴다.

[책임 경계(Separation of Concerns)]
- 애플리케이션은 계산/판단/정책 적용/검증을 수행한다.
- DB 트리거/DEFAULT/GENERATED ALWAYS STORED 등에 의해 자동 처리되는 필드는 애플리케이션이 재계산/재작성하지 않는다(중복 로직 금지).

[시간/날짜 처리 원칙]
- API로부터 수신된 날짜 문자열은 로직 처리 전에 Python datetime(UTC)로 정규화한다.
- YYYY-MM-DD는 UTC 00:00:00+00:00으로 간주한다.
- ISO8601 파싱 후 UTC 통일, DB 저장은 timestamptz(UTC).
- jsonb 내부 날짜는 타입 강제가 불가하므로 문자열로 저장하되, UTC ISO8601(+00:00) 포맷을 강제한다.
- 파싱 실패 또는 timezone 모호성은 400으로 실패 처리한다. (getConsensus event_date 규칙 포함)

[적재 전략(강제)]
- Insert-only(기존 변경 금지): evt_earning (중복 시 DO NOTHING)
- Upsert(갱신 허용): config_lv3_market_holidays, config_lv3_targets, evt_consensus, config_lv3_analyst, txn_events
  - 예: evt_consensus unique (ticker, event_date, analyst_name, analyst_company) 기반으로 upsert 키를 일치시킨다.
  - 예: txn_events unique (ticker, event_date, source, source_id) 준수.

[중요]
- “불일치 발견 시 자동 보정하지 않고 확인 후 결정” 원칙이 존재한다.
- 문서에 정의된 규칙·정책·제약이 존재하는 사항에 대해서는, 해석의 어려움이나 충돌을 이유로 사용자에게 질문하거나 재결정을 요구해서는 안 된다.
  - 이 경우에는 문서 규칙을 최우선으로 적용하고, “명시적 실패(400 등) / warn / skip” 중 하나로 처리한다.
- 단, 문서 전체를 기준으로 보았을 때 해당 항목에 대해 정의·정책·허용값·처리 규칙이 명시적으로 존재하지 않는 경우에 한하여, 그 항목을 “미정의(Underspecified)”로 분류하고 사용자에게 결정을 요청할 수 있다.
- “미정의” 여부 판단 시, 문서 일부만을 근거로 판단하는 것은 허용되지 않으며, 문서 전체를 검토한 뒤에만 인정된다.

────────────────────────────────────────────────────────
[강화 옵션: Lost in the Middle 추가 방지 규칙 — 필수 적용]
────────────────────────────────────────────────────────
(Option 1) 문서 근거 태그 강제
- Step 1~2의 모든 항목은 항목 끝에 반드시 근거 태그를 붙여라.
- 형식:
  - [SRC=guideline | KEY=<섹션명/키워드>]
  - [SRC=tables | KEY=<테이블명/제약/컬럼명>]

(Option 2) 중요 규칙 재반복
- Step 3 시작 직전에 아래 5개를 한 문장씩 재선언하라:
  1) 스키마 최종 권위
  2) DB 자동 처리 필드 재작성 금지
  3) UTC 정규화 + 파싱 실패=400
  4) insert-only vs upsert
  5) 충돌/불일치 처리: 자동 보정 금지, 대신 warn/skip/400

(Option 3) 코드 작성 순서 강제
- 구현은 반드시 다음 순서로 작성하라:
  1) DB 접근 레이어(커넥션/풀/트랜잭션/쿼리 함수)
  2) 공통 유틸(UTC 파서, 로깅 포맷터, rate/batch 조절기)
  3) 입력 검증 레이어(Pydantic 모델, 400 규칙)
  4) 도메인 서비스(각 endpoint의 phase 함수)
  5) FastAPI 라우터/핸들러
  6) 응답 DTO(레코드 단위 결과 + summary)

(Option 4) 실패 우선 정책
- 모호/불일치 케이스에서 임의 디폴트/추론/자동 보정 금지.
- 처리 방법은 다음 중 하나로만:
  - 400 Bad Request(입력/파싱/허용값 위반)
  - skip(정책상 허용되는 경우만) + counters.skip 증가
  - warn 코드 추가 + 명시 로그

────────────────────────────────────────────────────────
1) 작업 방식 강제: 3단계 계약(Contract) 프로토콜
────────────────────────────────────────────────────────
아래 3단계를 순서대로 수행하라. 각 단계 산출물은 반드시 포함되어야 하며, 누락 여부를 스스로 점검하라.

[Step 1: 해석 계약 — 코드 작성 금지]
(1) “불변 규칙” 목록 작성 (권위/책임/시간/적재/오류·로그/성능 포함)
(2) “애플리케이션이 절대 쓰면 안 되는 컬럼/필드”를 테이블별로 정리
    - 예: created_at(기본값), updated_at(자동 갱신), GENERATED ALWAYS STORED(예: analyst_name_key/analyst_company_key) 등
(3) 엔드포인트/모드/파라미터 트리의 입력 검증 규칙 명시
    - GET /sourceData mode 규칙(미지정 시 기본 순서, 복수 지정 시 중복 제거 후 기본 순서, 허용되지 않은 값=400)
    - calc_mode/calc_scope 및 하위 파라미터 누락/허용값 위반=400
(4) 지침 vs DB 충돌 가능 지점과 “충돌 시 처리 원칙” 재선언

[Step 2: 정규형 재구성 — 의미 축약 금지, 재배열만 허용]
아래 고정 구조로 “정규형 명세”를 작성하라.
A. 공통 규칙(권위/책임/시간/로그/성능)
B. DB 테이블별 명세(키/제약/쓰기 금지/업서트 전략)
C. 엔드포인트별 명세(입력→처리 단계→DB 동작→출력)
D. 기능별 Phase 정의 (예: getConsensus Phase1 Raw Upsert / Phase2 Change Detection)
E. 실패/경고/스킵 정책(HTTP status, warn 코드, counters 반영)

[Step 3: 구현 계약 — 코드 작성]
- Step 2 정규형 명세만을 근거로 코드를 구현하라.
- FastAPI 프로젝트 형태로 “실행 가능한 코드”를 제시하라.
- DB 연결은 반드시 직접 Postgres(DSN)로 연결한다.
- DB 작업은 가능한 경우 트랜잭션을 사용하고, idempotency/unique 제약을 활용한다.
- 모든 처리 단계는 로그 규칙(1줄 key=value 포맷)으로 출력한다.
- 결과 반환은 레코드 단위 성공/실패 + summary 집계 포함 (Multi-Status 필요 시 207 사용).

────────────────────────────────────────────────────────
2) 구현 대상(필수)
────────────────────────────────────────────────────────
필수 엔드포인트:
- GET /sourceData
- POST /setEventsTable
- POST /backfillEventsTable
- POST /fillAnalyst

각 엔드포인트는 반드시 포함:
- 입력 파라미터 검증(허용되지 않은 값 → 400)
- 정책 파라미터 반영(dryRun, overwrite, past, calc_mode/calc_scope 등)
- DB 쓰기 전략 준수(insert-only vs upsert)
- 로그 + counters + warn 배열 + summary 반환

특히 GET /sourceData:
- mode 미지정 시: 기본 순서로 전체 실행 (holiday → target → consensus → earning)
- mode 복수 지정 시: 중복 제거 후 기본 순서로 실행
- 허용되지 않은 mode 값 포함 시: 400

getConsensus:
- Phase1 Raw Upsert 완료 후에만 Phase2 실행한다.
- Phase1에서는 파생 컬럼(price_target_prev, direction, response_key.prev 등)을 계산/갱신하지 않는다.
- Phase2는 동일 (ticker, analyst_name, analyst_company) 파티션을 동시에 처리하지 않는 동시성 규칙을 준수한다.

────────────────────────────────────────────────────────
3) 코드 산출물 형식(필수)
────────────────────────────────────────────────────────
아래를 모두 제공하라.

(1) 설계 요약: 모듈/함수/Phase 분해
(2) 구현 코드: FastAPI 실행 가능한 형태
    - 권장 파일 구조(예시): app/main.py, app/db.py, app/schemas.py, app/services/*.py, app/logging.py
    - 의존성(예시): fastapi, uvicorn, pydantic, asyncpg(또는 psycopg3), python-dotenv(선택)
    - 환경변수(예시): DATABASE_URL(=Postgres DSN), LOG_LEVEL
(3) DB I/O 계약: 테이블별 upsert/insert 키 + 쓰기 금지 컬럼
(4) 자체 검증 체크리스트 결과(Yes/No):
    - GENERATED 컬럼을 직접 INSERT/UPDATE하는 코드가 있는가?
    - created_at/updated_at을 애플리케이션이 쓰는가?
    - evt_earning에 UPDATE/UPSERT가 존재하는가?
    - calc_mode/calc_scope 검증이 400을 반환하는가?
    - 날짜 파싱 실패/타임존 모호성에서 400으로 실패하는가?
    - 기본 모드에서 “영향받은 파티션만” Phase2 대상이 되는가?

[금지]
- “추가 정보가 필요합니다 / 확인이 필요합니다” 형태로 되묻지 마라.
- 문서 밖의 추론으로 정책을 채우지 마라.
- 누락은 실패로 간주한다.
